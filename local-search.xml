<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Nacos学习2—Nacos配置中心</title>
    <link href="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>在上一节中，介绍了Nacos配置中心的入门使用，在这一节，会讲解关于nacos配置中心的其他概念，比如命名空间、共享配置、以及如何在服务端更新nacos配置。</p><h3 id="1-nacos的基础概念"><a href="#1-nacos的基础概念" class="headerlink" title="1. nacos的基础概念"></a>1. nacos的基础概念</h3><p>如下图所示，在nacos配置中，namespace、group、dataId为最基础的、最重要的三个概念。<br>namespace: 命名空间可用于进行不同环境的配置隔离。一般一个环境划分到一个命名空间<br>group： 配置分组用于将不同的服务可以归类到同一分组。一般将一个项目的配置分到一组<br>dataId： 在系统中，一个配置文件通常就是一个配置集（dataId）。一般微服务的配置就是一个配置集</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image.png" class=""><p>当我们没有配置namespace时，其默认值就是public；没有配置group时，默认值为DEFAULT_GROUP，dataId默认是当前应用的application.name。<br>进入nacos，点击命名空间，选择新建命名空间</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image1.png" class=""><p>假设我们现在是在开发环境，然后我们创建一个dev命名空间，用于开发环境的相关配置,这里的命名空间id不用填，系统会自动生成</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image2.png" class=""><p>创建成功后，我们复制命名空间id</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image3.png" class=""><p>将这个命名空间id，粘贴到之前bootstrap.yml配置文件的namespace中</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image4.png" class=""><p>然后我们进入dev命名空间，新建一个配置</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image5.png" class=""><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image6.png" class=""><p>配置完毕后，启动项目，再次访问<a href="http://localhost:8080/test/hello%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8080/test/hello，结果如下：</a></p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image7.png" class=""><p>可见，此时读取到的，是dev命名空间下的配置。</p><h3 id="2-共享配置"><a href="#2-共享配置" class="headerlink" title="2. 共享配置"></a>2. 共享配置</h3><p>当我们项目中的服务数量增加后，配置文件也会相应的增加，而多个配置文件中，可能存在相同的配置，因此我们可以将这些相同的配置独立出来，作为该项目各个服务的共享配置文件。<br>假设我们现在有两个服务，这两个服务都共享同一个redis数据源和同一个mysql数据源，因此我们可以把这两个数据源的配置，提取成共享配置。<br>service1和service2的bootstrap.yml配置分别如下：</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image8.png" class=""><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image9.png" class=""><p>这两个服务的bootstrap配置文件内容，基本一样（除了端口号和服务名），除此之外，这里共享配置中，common-redis共享配置的refresh值设置为true，而common-mysql没有设置，也就是说，这两个服务能监听到common-redis配置的变化，而不会关注到common-mysql配置的变化。<br>配置完成后，这两个应用，我们都添加下面这个controller类，用于进行测试：</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image10.png" class=""><p>然后，我们在nacos上添加相关的共享配置</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image11.png" class=""><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image12.png" class=""><p>启动服务1和服务2，然后分别访问获取mysql配置和redis配置的接口</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image13.png" class=""><p>然后我们在分别修改mysql和redis的配置</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image14.png" class=""><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image15.png" class=""><p>然后再次访问相关的接口，结果如下：</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image16.png" class=""><p>由上图可知，如果公共配置想要获取实时数据，需要加上refresh属性的配置。</p><h3 id="3-扩展配置"><a href="#3-扩展配置" class="headerlink" title="3. 扩展配置"></a>3. 扩展配置</h3><p>一般情况下，我们的配置文件一个就可以了，但有时候，如果我们的配置分散在多个配置文件时，就需要使用到扩展配置了。<br>假设我们现在有两个扩展配置，一个是配置日志打印的，一个是配置消息队列，假设配置内容如下：<br>ext-log.yaml</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image17.png" class=""><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image18.png" class=""><p>bootstrap.yml内容如下：</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image19.png" class=""><p>添加一个controller用于测试</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image20.png" class=""><p>启动应用，结果如下：</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image21.png" class=""><p>然后我们修改扩展配置</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image22.png" class=""><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image23.png" class=""><p>再次访问相关的接口</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image24.png" class=""><p>可见，对于扩展配置，如果要获取实时数据，那么也需要加上refresh</p><h3 id="4-更新数据到nacos"><a href="#4-更新数据到nacos" class="headerlink" title="4. 更新数据到nacos"></a>4. 更新数据到nacos</h3><p>假设我们现在有一个数据迁移的任务，每隔一段时间，会触发这个任务一次，该任务会读取nacos配置中的起始时间和结束时间，然后查询数据库并将查询的数据进行迁移，最后会更新起始时间，然后修改nacos中的配置。<br>首先我们在nacos上添加一个和数据迁移相关的配置：</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image25.png" class=""><p>添加一个config，用于构造configService</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image26.png" class=""><p>添加一个定时任务，用于查询nacos配置，并根据nacos配置迁移数据</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image27.png" class=""><p>执行结果如下图所示，每隔十秒执行一次任务，并且将起始时间进行更新。</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A02%E2%80%94Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image28.png" class=""><h3 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h3><p>（超详细）关于Nacos的共享配置( shared-configs)和拓展配置(extension-config)：<a href="https://blog.csdn.net/weixin_42329623/article/details/131018680">https://blog.csdn.net/weixin_42329623/article/details/131018680</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nacos学习1—介绍、配置中心</title>
    <link href="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>在之前的Spring Cloud Gateway学习中，我们了解了网关相关配置，包括断言、过滤器等内容。在之前的文章中，我们是将这些配置，写到application.yml上，而一般情况下，我们Spring Cloud Gateway的网关配置，肯定不会是一成不变的，如果配置信息是在application.yml上，那么当我们需要添加其他的路由配置时，就先修改application.yml配置，然后重启服务，这不利于用户使用和产品的稳定。我们希望通过一个配置中心，来方便我们对这些路由信息进行统一的维护、管理。</p><h4 id="1-1-配置中心思路"><a href="#1-1-配置中心思路" class="headerlink" title="1.1. 配置中心思路"></a>1.1. 配置中心思路</h4><p>配置中心的一般思路为：<br>1） 首先把项目中的各种配置全部放到一个集中的地方进行统一管理，并提供一套标准接口。<br>2）当各个服务需要获取配置的时候，就来配置中心的接口拉取自己的配置。<br>3）当配置中心中的各种参数有更新的时候，也能通知到各个服务实时同步最新的消息，使之动态更新。<br>当加入服务配置中心后，我们的系统架构图如下：</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image.png" class=""><h4 id="1-2-常用的服务配置中心"><a href="#1-2-常用的服务配置中心" class="headerlink" title="1.2. 常用的服务配置中心"></a>1.2. 常用的服务配置中心</h4><p>Spring Cloud Config:官方提供的分布式系统的外部配置中心。<br>Nacos:阿里开源的框架，致力于发现、配置和管理微服务。Nacos提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。<br>Apollo：携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image1.png" class=""><h3 id="2-Nacos介绍和环境搭建"><a href="#2-Nacos介绍和环境搭建" class="headerlink" title="2. Nacos介绍和环境搭建"></a>2. Nacos介绍和环境搭建</h3><h4 id="2-1-Nacos介绍"><a href="#2-1-Nacos介绍" class="headerlink" title="2.1. Nacos介绍"></a>2.1. Nacos介绍</h4><p>Nacos是阿里巴巴推出的一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>Nacos的关键特性有以下几点：<br>1）服务发现和服务健康检测<br>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。<br>2）动态配置服务<br>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。<br>动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。<br>配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。<br>3）动态DNS服务<br>动态 DNS 服务支持权重路由，从而更方便地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。<br>4）服务及其元数据管理<br>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</p><h4 id="2-2-Nacos环境搭建"><a href="#2-2-Nacos环境搭建" class="headerlink" title="2.2. Nacos环境搭建"></a>2.2. Nacos环境搭建</h4><p>进入Nacos官网：<a href="https://nacos.io/">https://nacos.io</a></p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image2.png" class=""><p>点击前往github，跳转至github下载页面，然后点击tags选择要下载的版本</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image3.png" class=""><p>下载完毕后解压到需要安装的目录</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image5.png" class=""><p>解压完毕后，进入bin目录，修改启动文件startup.cmd，将mode由”cluster”改为standalone</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image6.png" class=""><p>修改完毕后，双击startup.cmd启动Nacos服务</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image7.png" class=""><p>访问<a href="http://localhost:8848/nacos%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E4%B8%BA%22nacos%22%E3%80%82">http://localhost:8848/nacos，默认的用户名和密码为&quot;nacos&quot;。</a></p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image8.png" class=""><h3 id="3-Nacos-Config配置中心"><a href="#3-Nacos-Config配置中心" class="headerlink" title="3. Nacos Config配置中心"></a>3. Nacos Config配置中心</h3><h4 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1. 基本使用"></a>3.1. 基本使用</h4><p>添加Nacos config的依赖</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image9.png" class=""><p>注意，如果是在springboot2.4.x的版本之后，对于bootstrap.properties和bootstrap.yaml配置文件，需要在pom中加入依赖：</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image10.png" class=""><p>然后添加配置文件，注意，不能使用application.yml，要新建一个bootstrap.yml作为配置文件<br>配置文件有优先级为：<br>bootstrap.properties  &gt; bootstrap.yml &gt; application.properties &gt; application.yml<br>假设我们当前的配置如下：</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image11.png" class=""><p>然后我们添加一个controller用于测试，下面这个controller的hello方法，会返回helloWorld的值，这里我先设置了一个默认值为“defalut value”</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image12.png" class=""><p>当我们的hello.world在nacos上没有进行配置时，那么我们访问<a href="http://localhost/test/hello%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">http://localhost:80/test/hello，结果如下图所示：</a></p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image13.png" class=""><p>现在我进入nacos官网，新建对应的配置，如下图所示，点击左边的创建配置</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image14.png" class=""><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image15.png" class=""><p>然后填写dataId,group,配置类型和配置的内容，注意，这里的data id要和我们的bootstrap.yml中配置的spring.cloud.nacos.config.name保持一致(如果不配置也可以，不配置的话，默认使用application.name的名称对应的配置）</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image16.png" class=""><p>配置完毕后点击发布</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image17.png" class=""><p>发布完成后，我们再次访问<a href="http://localhost/test/hello">http://localhost:80/test/hello</a></p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image18.png" class=""><h4 id="3-2-dataId"><a href="#3-2-dataId" class="headerlink" title="3.2. dataId"></a>3.2. dataId</h4><p>之所以配置spring.application.name或spring.cloud.nacos.config.name，是因为它是构成Nacos配置管理dataId字段的一部分。在Nacos 中，dataId完整格式如下：<br>${prefix}-${spring.profiles.active}.${file-extension}<br>prefix: 默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.name来配置<br>spring.profiles.active:当前环境对应的profile，当spring.profiles.active为空时，对应的连接符-也不存在<br>file-extension：配置内容的数据格式，可以通过spring.cloud.nacos.config.file-extension来配置，目前只支持properties和yaml类型<br>我们修改刚才的bootstrap.yaml配置文件，修改结果如下：</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image19.png" class=""><p>然后在nacos添加一个配置</p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image20.png" class=""><p>然后重启应用，访问<a href="http://localhost:8080/test/hello%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8080/test/hello，结果如下：</a></p><img src="/2024/04/02/Nacos%E5%AD%A6%E4%B9%A01%E2%80%94%E4%BB%8B%E7%BB%8D%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image21.png" class=""><h4 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4. 参考文章"></a>4. 参考文章</h4><p>使用nacos作为配置中心：<a href="https://blog.csdn.net/weixin_65211978/article/details/128102799">https://blog.csdn.net/weixin_65211978/article/details/128102799</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringGateway学习2</title>
    <link href="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/"/>
    <url>/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/</url>
    
    <content type="html"><![CDATA[<h3 id="1-断言"><a href="#1-断言" class="headerlink" title="1. 断言"></a>1. 断言</h3><p>在上一节中，我们的gateway应用，它的配置文件为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service1</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9000</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment">#断言，为真则匹配成功</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app1/**</span> <span class="hljs-comment">#配置规则Path，如果是app1开头的请求，会转发到目标URL</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service2</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9001</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app2/**</span><br></code></pre></td></tr></table></figure><p>这里面使用了Path断言，Path断言会根据请求的路径进行匹配，除了Path断言外，常用的断言如下图所示：</p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image.png" class=""><p>这里再简单介绍几个常用的断言：</p><h4 id="1-1-After"><a href="#1-1-After" class="headerlink" title="1.1. After"></a>1.1. After</h4><p>After用于匹配在指定日期时间之后发生的请求，也就是说，只有在指定日期之后的请求，才能被转发，假设我们的配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service1</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9000</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment">#断言，为真则匹配成功</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">After=2025-01-20T09:08:01.000+08:00[Asia/Shanghai]</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app1/**</span> <span class="hljs-comment">#配置规则Path，如果是app1开头的请求，会转发到目标URL</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service2</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9001</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app2/**</span><br></code></pre></td></tr></table></figure><p>在1月20号9点8分之前：</p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image1.png" class=""><p>在1月20号9点8分之后：</p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image2.png" class=""><h4 id="1-2-Before"><a href="#1-2-Before" class="headerlink" title="1.2. Before"></a>1.2. Before</h4><p>Before用于匹配在指定日期之前的请求，也就是说，只有在指定日期之前，该请求才会被匹配并转发<br>假设我们的配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service1</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9000</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment">#断言，为真则匹配成功</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">After=2024-01-20T09:08:01.000+08:00[Asia/Shanghai]</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app1/**</span> <span class="hljs-comment">#配置规则Path，如果是app1开头的请求，会转发到目标URL</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service2</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9001</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Before=2024-01-20T09:17:01.000+08:00[Asia/Shanghai]</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app2/**</span><br></code></pre></td></tr></table></figure><p>在1月20号9点17分之前：</p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image3.png" class=""><p>在1月20号9点17分之后：</p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image4.png" class=""><h3 id="2-网关过滤器"><a href="#2-网关过滤器" class="headerlink" title="2. 网关过滤器"></a>2. 网关过滤器</h3><h4 id="2-1-Gateway-Filter"><a href="#2-1-Gateway-Filter" class="headerlink" title="2.1. Gateway Filter"></a>2.1. Gateway Filter</h4><p>SpringCloud Gateway的Filter分为两种类型：Gateway Filter和Global Filter，过滤器会对请求和响应进行处理，比如添加参数，URL重写等，常用的网关过滤器如下：</p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image5.png" class=""><h5 id="2-1-1-AddRequestHeader"><a href="#2-1-1-AddRequestHeader" class="headerlink" title="2.1.1. AddRequestHeader"></a>2.1.1. AddRequestHeader</h5><p>AddRequestHeader需要name和value参数<br>假设我们修改gateway应用的配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service1</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9000</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment">#断言，为真则匹配成功</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app1/**</span> <span class="hljs-comment">#配置规则Path，如果是app1开头的请求，会转发到目标URL</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Request-red,blue</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service2</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9001</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app2/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Request-red,blue</span><br></code></pre></td></tr></table></figure><p>这里会将blue消息头添加到所有匹配请求的下游请求消息头中<br>然后修改app-service1应用的controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/app1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App1Controller</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">test</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        System.out.println(request.getHeader(<span class="hljs-string">&quot;X-Request-red&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;app1&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改app-service2应用的controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/app2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App2Controller</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">test</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        System.out.println(request.getHeader(<span class="hljs-string">&quot;X-Request-red&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;app2&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分别访问<a href="http://localhost/app1/test%E5%92%8Chttp://localhost/app2/test%EF%BC%8C%E7%84%B6%E5%90%8E%E6%9F%A5%E7%9C%8B%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%8C%E5%8F%91%E7%8E%B0%E7%A1%AE%E5%AE%9E%E6%9C%89%E6%B7%BB%E5%8A%A0%E4%B8%8Ablue%E8%AF%B7%E6%B1%82%E5%A4%B4">http://localhost/app1/test和http://localhost/app2/test，然后查看控制台，发现确实有添加上blue请求头</a></p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image6.png" class=""><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image7.png" class=""><h5 id="2-1-2-AddRequestParameter"><a href="#2-1-2-AddRequestParameter" class="headerlink" title="2.1.2. AddRequestParameter"></a>2.1.2. AddRequestParameter</h5><p>AddRequestParamter需要name和value参数<br>我们修改gateway的配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service1</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9000</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment">#断言，为真则匹配成功</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app1/**</span> <span class="hljs-comment">#配置规则Path，如果是app1开头的请求，会转发到目标URL</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Request-red,blue</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestParameter=red,blue</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service2</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9001</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app2/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Request-red,blue</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestParameter=red,blue</span><br></code></pre></td></tr></table></figure><p>这里表示将red&#x3D;blue添加到下游请求参数中<br>我们修改app-service1和app-service2的controller代码，方便查看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/app1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App1Controller</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">test</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        System.out.println(request.getHeader(<span class="hljs-string">&quot;X-Request-red&quot;</span>));<br>        System.out.println(request.getParameter(<span class="hljs-string">&quot;red&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;app1&quot;</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/app2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App2Controller</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">test</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        System.out.println(request.getHeader(<span class="hljs-string">&quot;X-Request-red&quot;</span>));<br>        System.out.println(request.getParameter(<span class="hljs-string">&quot;red&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;app2&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分别访问<a href="http://localhost/app1/test%E5%92%8Chttp://localhost/app2/test%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost/app1/test和http://localhost/app2/test，结果如下：</a></p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image8.png" class=""><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image9.png" class=""><h4 id="2-2-GlobalFilter"><a href="#2-2-GlobalFilter" class="headerlink" title="2.2. GlobalFilter"></a>2.2. GlobalFilter</h4><p>GlobalFilter是应用于所有路由的特殊过滤器</p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image10.png" class=""><p>通过全局网关过滤器，我们可以很方便的实现统一鉴权，下面我们自定义一个全局过滤器，通过token判断用户是否登录，从而实现一个统一的鉴权。<br>我们在gateway项目中，添加一个鉴权的全局网关过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.young.filter;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;<br><span class="hljs-keyword">import</span> org.springframework.core.Ordered;<br><span class="hljs-keyword">import</span> org.springframework.core.io.buffer.DataBuffer;<br><span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;<br><span class="hljs-keyword">import</span> org.springframework.http.server.reactive.ServerHttpResponse;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;<br><span class="hljs-keyword">import</span> reactor.core.publisher.Flux;<br><span class="hljs-keyword">import</span> reactor.core.publisher.Mono;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">servletResponse</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">servletRequest</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        <span class="hljs-comment">// 获取token参数</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> servletRequest.getHeaders().getFirst(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(token)) &#123;<br>            servletResponse.setStatusCode(HttpStatus.UNAUTHORIZED);<br>            servletResponse.getHeaders().add(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>            jsonObject.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;403&quot;</span>);<br>            jsonObject.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;token is empty&quot;</span>);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">DataBuffer</span> <span class="hljs-variable">dataBuffer</span> <span class="hljs-operator">=</span> servletResponse.bufferFactory().wrap(jsonObject.toJSONString().getBytes());<br>            <span class="hljs-keyword">return</span> servletResponse.writeWith(Flux.just(dataBuffer));<br>        &#125;<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新启动项目，然后访问<a href="http://localhost/app1/test">http://localhost/app1/test</a></p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image11.png" class=""><p>由于没有携带token，因此被拦截住，假设我们现在在请求头上添加token，再次访问，结果如下：</p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A02/image12.png" class=""><p>此时能够访问成功，这里只是为了演示，因此鉴权逻辑写的比较简单，真实情况下的鉴权，可以基于此进行扩展和补充。</p><h3 id="3-参考文档"><a href="#3-参考文档" class="headerlink" title="3. 参考文档"></a>3. 参考文档</h3><p><a href="https://blog.csdn.net/zouliping123456/article/details/116128179">https://blog.csdn.net/zouliping123456/article/details/116128179</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringGateway学习1</title>
    <link href="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A01/"/>
    <url>/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>API网关是一个服务器，是系统对外的唯一入口，对于服务数量众多、复杂度比较高、规模比较大的业务来说，引入API网关有以下好处：<br>1） 聚合接口使得服务对调用者透明，客户端与后端耦合度降低<br>2） 聚合后台服务，节省流量，提高性能和用户体验<br>3）提供安全、流控、过滤、缓存、计费、监控等API管理功能<br>SpringCloud Gateway是基于Spring生态系统之上搭建的API网关，包括：Spring5， SpringBoot2和Project Reactor。Spring Cloud Gateway旨在提供一种简单有效的方法来路由到API，并为它们提供领域的关注点，例如安全性、监控&#x2F;指标、限流等。</p><h3 id="2-核心概念和原理"><a href="#2-核心概念和原理" class="headerlink" title="2. 核心概念和原理"></a>2. 核心概念和原理</h3><h4 id="2-1-核心概念"><a href="#2-1-核心概念" class="headerlink" title="2.1. 核心概念"></a>2.1. 核心概念</h4><p>路由（Route）：路由信息由ID、目标URL、一组断言和一组过滤器组成，如果断言路由为真，说明请求的URI和配置匹配<br>断言（Predicate）：Java8中的断言函数，SpringCloud Gateway中的断言函数，允许开发者去定义匹配来自Http Request中的任何信息，比如请求头和参数等<br>过滤器（Filter）：在SpringCloud Gateway中，有两种过滤器：Gateway Filter 和 Global Filter，过滤器负责对请求和响应进行处理。</p><h4 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2. 工作原理"></a>2.2. 工作原理</h4><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A01/image1.png" class=""><p>客户端向Spring Cloud Gateway发出请求，由网关处理程序Gateway Handler Mapping映射确定与请求相匹配的路由（route），将其发送到网关web处理程序Gateway Web Handler，该程序通过指定的过滤器将请求发送到实际的服务，执行业务逻辑，然后返回。<br>过滤器由虚线分隔的原因是，过滤器可以在发送代理请求之前和之后运行逻辑。所有 pre过滤器逻辑均被执行。然后发出代理清求。发出代理清求后，将运行post过滤器逻辑。</p><h3 id="3-入门案例"><a href="#3-入门案例" class="headerlink" title="3. 入门案例"></a>3. 入门案例</h3><h4 id="3-1-创建普通的web项目，并测试相关接口"><a href="#3-1-创建普通的web项目，并测试相关接口" class="headerlink" title="3.1. 创建普通的web项目，并测试相关接口"></a>3.1. 创建普通的web项目，并测试相关接口</h4><p>创建一个maven项目，在该maven项目下，创建三个子模块，假设分别命名为gateway、app-service1、app-service2</p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A01/image2.png" class=""><p>在父模块的pom.xml中，添加相关的版本管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloudgateway1<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>gateway<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>app-service1<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>app-service2<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring.boot.version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">spring.boot.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring.cloud.version</span>&gt;</span>2020.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">spring.cloud.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring.cloud.alibaba.version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.cloud.alibaba.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--Spring版本--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在gateway模块，添加下列依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>app-service1和app-service2模块，添加下列依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在app-service1模块，添加启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.young;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service1App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Service1App.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加一个controller类用于测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/app1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App1Controller</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;app1&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>application.yml配置信息如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9000</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">app-service1</span><br></code></pre></td></tr></table></figure><p>在app-service2中，添加启动类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service2App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Service2App</span>.<span class="hljs-property">class</span>, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对外controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/app2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App2Controller</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;app2&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9001</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">app-service2</span><br></code></pre></td></tr></table></figure><p>启动app-service1和app-service2，然后访问<a href="http://localhost:9000/app1/test%E5%92%8Chttp://localhost:9001/app2/test%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:9000/app1/test和http://localhost:9001/app2/test，结果如下：</a></p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A01/image3.png" class=""><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A01/image4.png" class=""><h4 id="3-2-配置网关转发"><a href="#3-2-配置网关转发" class="headerlink" title="3.2. 配置网关转发"></a>3.2. 配置网关转发</h4><p>在gateway模块，添加启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayApp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(GatewayApp.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改配置文件，配置路由转发规则</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service1</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9000</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment">#断言，为真则匹配成功</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app1/**</span> <span class="hljs-comment">#配置规则Path，如果是app1开头的请求，会转发到目标URL</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">app-service2</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9001</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/app2/**</span><br></code></pre></td></tr></table></figure><p>启动gateway项目，使用gateway的端口，进行测试</p><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A01/image5.png" class=""><img src="/2024/04/02/SpringGateway%E5%AD%A6%E4%B9%A01/image6.png" class="">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p>Executors是一个工厂类，提供了创建几种预配置线程池实例地方法，如果不需要应用任何自定义地微调，可以调用这些方法创建默认配置地线程池。Executors工厂类提供地线程池有以下几种：<br>1）newCachedThreadPool(): 创建一个可缓存地线程池，这个线程池地线程数量可以根据需要自动扩展，如果有可用的空闲线程，就会重用它们；如果没有可用的线程，就会创建一个新线程，适用于执行大量的短期异步任务。<br>2）newFixedThreadPool(int nThreads): 创建一个固定大小的线程池，其中包含指定数量的线程，线程数量是固定的，不会自动扩展，适用于执行固定数量的长期任务。<br>3）newSingleThreadExecutor(): 创建一个单线程的线程池，用于串行执行任务。适用于需要按顺序执行任务的场景。<br>4）newScheduledThreadPool(int corePoolSize): 创建一个单线程的定时执行线程池。只包含一个线程，用于串行定时执行任务。<br>5）newWorkStealingPool(int parallelism): 创建一个工作窃取线程池，线程数量根据CPU核心数动态调整，适用于CPU密集型的任务。</p><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>ExecutorService是java.util.concurrent包的重要组成部分，是Java JDK提供的框架，用于简化异步模式下任务的执行。一般来说，ExecutorService会自动提供一个线程池和相关API，用于为其分配任务。</p><h4 id="工厂方法实例化ExecutorService"><a href="#工厂方法实例化ExecutorService" class="headerlink" title="工厂方法实例化ExecutorService"></a>工厂方法实例化ExecutorService</h4><p>Executors类提供了许多工厂方法用于实例化ExecutorService，最常用的是newFixedThreadPool方法，用于创建指定线程数的ExecutorService实例，使用方法如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ExecutorService executor = Executors.newFixedThreadPool(10);<br></code></pre></td></tr></table></figure><h4 id="直接创建ExecutorService实例"><a href="#直接创建ExecutorService实例" class="headerlink" title="直接创建ExecutorService实例"></a>直接创建ExecutorService实例</h4><p>ExecutorService是一个接口，因此可以使用其任何实现类的实例，例如ThreadPoolExecutor类实现了ExecutorService接口并提供了一些构造函数用于配置执行程序服务及其内部池。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">int core = Runtime.getRuntime().availableProcessors();<br>int max = Runtime.getRuntime().availableProcessors() * 2 + 1;<br>int wait = 60;<br>int capacity = 500;<br>ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(core, max, wait, TimeUnit.SECONDS,<br>      new LinkedBlockingQueue<span class="hljs-tag">&lt;&gt;</span>(capacity),<br>      Executors.defaultThreadFactory(),<br>      new ThreadPoolExecutor.CallerRunsPolicy());<br></code></pre></td></tr></table></figure><p>这里的参数，从左到右分别表示：<br>1）corePoolSize：核心线程数<br>2）maxPoolSize：最大线程数<br>3）keepAliveTime：额外的线程（即实例化超过corePoolSize的线程）在空闲状态下的存活时间。<br>4）unit：等待时间单位<br>5）workQueue：任务队列<br>6）threadFactory：线程工厂<br>7）handler：拒绝策略<br>其中，拒绝策略主要有以下几种：<br>1）AbortPolicy：直接抛出RejectedExecutionException异常阻止系统正常运行。<br>2）CallerRunsPolicy：既不抛弃任务，也不抛出异常，而是将某些任务回退给调用者，从而降低任务的流量。<br>3）DiscardOldestPolicy：抛出等待队列中最先等待的任务，然后把当前任务加入队列中。<br>4）DiscardPolicy：既不处理也不抛出异常，如果允许任务丢弃，这是最好的方法。</p><h4 id="任务分配给ExecutorService"><a href="#任务分配给ExecutorService" class="headerlink" title="任务分配给ExecutorService"></a>任务分配给ExecutorService</h4><p>ExecutorService可以执行Runnable和Callable任务，首先我们创建两个原始任务类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static List&lt;Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>&gt; buildCallableTasks() &#123;<br>      Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> callableTask = () -&gt; &#123;<br>          TimeUnit.MILLISECONDS.sleep(300);<br>          System.out.println(&quot;buildCallable==========&quot;);<br>          return &quot;Task&#x27;s execution&quot;;<br>      &#125;;<br><br>      List&lt;Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>&gt; callableTasks = new ArrayList<span class="hljs-tag">&lt;&gt;</span>();<br>      callableTasks.add(callableTask);<br>      callableTasks.add(callableTask);<br>      callableTasks.add(callableTask);<br>      return callableTasks;<br>  &#125;<br><br>  private static Runnable buildRunnable() &#123;<br>      return () -&gt; &#123;<br>          try &#123;<br>              TimeUnit.MILLISECONDS.sleep(300);<br>              System.out.println(&quot;buildRunnable===========&quot;);<br>          &#125; catch (InterruptedException e) &#123;<br>              e.printStackTrace();<br>          &#125;<br>      &#125;;<br>  &#125;<br></code></pre></td></tr></table></figure><p>创建完任务之后，可以使用多种方法将任务分配给ExecutorService.</p><h5 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h5><p>改方法返回值为空(void),因此改方法没有任何可能获得任务执行结果或检查任务的状态。使用示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testExecute() &#123;<br>       ExecutorService executorService = Executors.newFixedThreadPool(2);<br>       Runnable runnable = buildRunnable();<br>       executorService.execute(runnable);<br>       System.out.println(&quot;hello world=========&quot;);<br>   &#125;<br></code></pre></td></tr></table></figure><p>在main方法中调用该方法，结果如下：</p><img src="/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image.png" class=""><h5 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h5><p>submit方法会将一个Callable或Runnable任务提交给ExecutorService并返回future类型的结果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testSubmit() throws ExecutionException, InterruptedException &#123;<br>       ExecutorService executorService = Executors.newFixedThreadPool(2);<br>       Runnable runnable = buildRunnable();<br>       List&lt;Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>&gt; callableTasks = buildCallableTasks();<br>       Future&lt;?&gt; runnableFuture = executorService.submit(runnable);<br>       List&lt;Future<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>&gt; callableFutures = new ArrayList<span class="hljs-tag">&lt;&gt;</span>();<br>       for (Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> callableTask : callableTasks) &#123;<br>           callableFutures.add(executorService.submit(callableTask));<br>       &#125;<br>       System.out.println(runnableFuture.get());<br>       for (Future<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> callableFuture : callableFutures) &#123;<br>           System.out.println(callableFuture.get());<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>通过future类的get方法，能获取返回的结果，如果提交的是一个Runnable任务，那么通过future的get方法，返回的是一个null，如下图所示：</p><img src="/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image(1).png" class=""><h5 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny"></a>invokeAny</h5><p>invokeAny方法将一组任务分配给ExecutorService，使每个任务执行，并返回任意一个成功执行的任务结果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testInvokeAny() throws ExecutionException, InterruptedException &#123;<br>      ExecutorService executorService = Executors.newFixedThreadPool(2);<br>      List&lt;Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>&gt; callableTasks = buildCallableTasks();<br>      String result = executorService.invokeAny(callableTasks);<br>      System.out.println(result);<br>  &#125;<br></code></pre></td></tr></table></figure><p>结果如下所示：</p><img src="/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image(2).png" class=""><h5 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h5><p>invokeAll方法将一组任务分配给ExecutorService，使每个任务执行，并以Future类型的对象列表形式返回所有任务执行的结果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testInvokeAll() throws InterruptedException, ExecutionException &#123;<br>       ExecutorService executorService = Executors.newFixedThreadPool(2);<br>       List&lt;Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>&gt; callableTasks = buildCallableTasks();<br>       List&lt;Future<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>&gt; futures = executorService.invokeAll(callableTasks);<br>       for (Future<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> future : futures) &#123;<br>           System.out.println(future.get());<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><img src="/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image(3).png" class=""><h4 id="关闭ExecutorService"><a href="#关闭ExecutorService" class="headerlink" title="关闭ExecutorService"></a>关闭ExecutorService</h4><p>一般情况下，ExecutorService并不会自动关闭，即使所有任务都执行完毕，或者没有要处理的任务，也不会自动销毁ExecutorService，会一直处于等待状态，等待我们给他分配新的工作。当应用程序需要处理不定期出现的任务时，这种机制很有用，但是也带来一些副作用：即使应用程序到达它的终点，也不会被停止，因为等待ExecutorService将导致JVM继续运行，这样，我们就需要主动关闭Executor Service。<br>要关闭ExecutorService，可以使用shutdown方法或shutdownNow方法</p><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><p>shutdown方法并保护会立即销毁ExecutorService实例，而是首先让ExecutorService停止接受新任务，并且在所有正在运行的线程完成当前工作后关闭。</p><h5 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h5><p>shutdownNow() 方法会尝试立即销毁 ExecutorService 实例，所以并不能保证所有正在运行的线程将同时停止。该方法会返回等待处理的任务列表，由开发人员自行决定如何处理这些任务。<br>因为提供了两个方法，因此关闭 ExecutorService 实例的最佳实战 （ 也是 Oracle 所推荐的 ）就是同时使用这两种方法并结合 awaitTermination() 方法。<br>使用这种方式，ExecutorService 首先停止执行新任务，等待指定的时间段完成所有任务。如果该时间到期，则立即停止执行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testInvokeAll() throws InterruptedException, ExecutionException &#123;<br>     ExecutorService executorService = Executors.newFixedThreadPool(2);<br>     List&lt;Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>&gt; callableTasks = buildCallableTasks();<br>     List&lt;Future<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>&gt; futures = executorService.invokeAll(callableTasks);<br>     for (Future<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> future : futures) &#123;<br>         System.out.println(future.get());<br>     &#125;<br>     executorService.shutdown();<br>     try &#123;<br>         if (!executorService.awaitTermination(800, TimeUnit.MILLISECONDS)) &#123;<br>             executorService.shutdownNow();<br>         &#125;<br>     &#125; catch (InterruptedException e) &#123;<br>         executorService.shutdownNow();<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>在ExecutorService的submit方法、invokeAll方法，都会返回一个Future对象或Future对象集合，这些Future接口的对象允许我们获取任务执行的结果或检查任务状态（运行中还是执行完毕）</p><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>future接口提供一个特殊的阻塞方法get，它返回callable任务执行的实际结果，但如果是runnable任务，只会返回null。此外，正在执行的任务随时可能抛出异常或中断执行，因此我们要将get调用放在try catch语句块中，以捕获InterruptedException或ExecutionException异常。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testFutureGet() &#123;<br>      ExecutorService executorService = Executors.newFixedThreadPool(2);<br>      Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> callable = () -&gt; &#123;<br>          System.out.println(&quot;执行callable任务&quot;);<br>          TimeUnit.MILLISECONDS.sleep(300);<br>          return &quot;callable执行完毕&quot;;<br>      &#125;;<br>      Future<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> future = executorService.submit(callable);<br>      try &#123;<br>          String result = future.get();<br>          System.out.println(result);<br>      &#125; catch (InterruptedException | ExecutionException e) &#123;<br>          e.printStackTrace();<br>      &#125;<br>      executorService.shutdown();<br>      try &#123;<br>          if (!executorService.awaitTermination(800, TimeUnit.MILLISECONDS)) &#123;<br>              executorService.shutdownNow();<br>          &#125;<br>      &#125; catch (InterruptedException e) &#123;<br>          executorService.shutdownNow();<br>      &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>因为get方法是阻塞的，并且不知道要阻塞多长时间，因此可能导致应用程序的性能降低，如果结果数据并不重要，我们可以使用超时机制来避免长时间阻塞，也就是使用get的重载方法，第一个参数为超时时间，第二个参数为时间的单位。如果在超时时间内正常结束，那么返回Future的结果，如果超时了还没结束，那么将抛出TimeoutExeception异常。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testFutureGet() &#123;<br>        ExecutorService executorService = Executors.newFixedThreadPool(2);<br>        Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> callable = () -&gt; &#123;<br>            System.out.println(&quot;执行callable任务&quot;);<br>            TimeUnit.MILLISECONDS.sleep(300);<br>            return &quot;callable执行完毕&quot;;<br>        &#125;;<br>        Future<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> future = executorService.submit(callable);<br>        try &#123;<br>            String result = future.get(400, TimeUnit.MILLISECONDS);<br>            System.out.println(result);<br>        &#125; catch (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> callable2 = () -&gt; &#123;<br>            System.out.println(&quot;执行callable任务&quot;);<br>            TimeUnit.MILLISECONDS.sleep(500);<br>            return &quot;callable执行完毕&quot;;<br>        &#125;;<br>        Future<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> future2 = executorService.submit(callable2);<br>        try &#123;<br>            String result = future2.get(400, TimeUnit.MILLISECONDS);<br>            System.out.println(result);<br>        &#125; catch (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        executorService.shutdown();<br>        try &#123;<br>            if (!executorService.awaitTermination(800, TimeUnit.MILLISECONDS)) &#123;<br>                executorService.shutdownNow();<br>            &#125;<br>        &#125; catch (InterruptedException e) &#123;<br>            executorService.shutdownNow();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>执行结果如下，第一个任务没有超时，所以能正常获取结果，第二个任务超时，所以会抛出异常。</p><img src="/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image(4).png" class=""><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>除了get方法外，Future还提供许多方法，主要的方法如下：<br>1）isDone： 检查已分配的任务是否已处理<br>2）cancel： 取消任务执行<br>3）isCancelled：检查任务是否已取消</p><h3 id="ScheduledExecutorService接口"><a href="#ScheduledExecutorService接口" class="headerlink" title="ScheduledExecutorService接口"></a>ScheduledExecutorService接口</h3><p>ScheduledExecutorService接口用于在一些预定义的延迟之后运行任务或定期运行任务。我们可以通过Executors类的工厂方法实例化ScheduledExecutorService，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();<br></code></pre></td></tr></table></figure><p>在ScheduledExecutorService接口中，有三个主要方法：<br>1）schedule：允许在指定的延迟后执行一次任务。<br>2）scheduleAtFixedRate：允许在指定的初始延迟后执行任务，然后以一定的周期重复执行，其中period参数用于指定两个任务的开始时间之间的间隔时间，因此任务执行的频率是固定的。<br>3）scheduleWithFixedDelay：类似于scheduleAtFixedRate，它也重复执行给定的任务，单period参数用于指定前一个任务的结束和下一个任务的开始之间的间隔时间，也就是指定下一个任务延时多久后才执行，执行频率可能会有所不同，具体取决于执行任务给定任务所需的时间。</p><h4 id="scheduled方法"><a href="#scheduled方法" class="headerlink" title="scheduled方法"></a>scheduled方法</h4><p>假设要在固定延迟后安排某个任务的执行，可以使用ScheduledExecutorService实例的scheduled方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testScheduled() &#123;<br>        ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();<br>        Callable<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> callable = () -&gt; &#123;<br>            System.out.println(&quot;执行callable任务====&quot;);<br>            return &quot;callable&quot;;<br>        &#125;;<br>        ScheduledFuture<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> schedule = scheduledExecutorService.schedule(callable, 1, TimeUnit.SECONDS);<br>        System.out.println(&quot;主线程运行中========&quot;);<br>        try &#123;<br>            System.out.println(schedule.get());<br>        &#125; catch (InterruptedException | ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        scheduledExecutorService.shutdown();<br>        try &#123;<br>            if (!scheduledExecutorService.awaitTermination(800, TimeUnit.MILLISECONDS)) &#123;<br>                scheduledExecutorService.shutdownNow();<br>            &#125;<br>        &#125; catch (InterruptedException  e) &#123;<br>            scheduledExecutorService.shutdownNow();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果如下，在延迟一秒后，才开始执行线程任务：</p><img src="/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image(5).png" class=""><h4 id="scheduleAtFixedRate方法"><a href="#scheduleAtFixedRate方法" class="headerlink" title="scheduleAtFixedRate方法"></a>scheduleAtFixedRate方法</h4><p>当我们需要在固定延迟后，定期执行任务时，可以使用scheduleAtFixedRate方法，如下所示，每隔500毫秒执行相同的任务：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testScheduleAtFixRate() &#123;<br>       ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();<br>       Runnable runnable = () -&gt; &#123;<br>           System.out.println(System.currentTimeMillis());<br>           System.out.println(&quot;执行callable任务====&quot;);<br>       &#125;;<br>       // 延迟1秒后，每间隔2秒执行一次<br>       scheduledExecutorService.scheduleAtFixedRate(runnable, 1, 2, TimeUnit.SECONDS);<br>   &#125;<br></code></pre></td></tr></table></figure><p>结果如下所示，从时间戳我们可以看出，确实是每隔2秒执行一次</p><img src="/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image(6).png" class=""><p>如果任务执行时间比间隔时间长，那么scheduledExecutorService将等到当前任务执行后再开始下一个任务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testScheduleAtFixRate() &#123;<br>       ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();<br>       Runnable runnable = () -&gt; &#123;<br>           System.out.println(System.currentTimeMillis());<br>           try &#123;<br>               TimeUnit.SECONDS.sleep(3);<br>           &#125; catch (InterruptedException e) &#123;<br>               throw new RuntimeException(e);<br>           &#125;<br>           System.out.println(&quot;执行callable任务====&quot;);<br>       &#125;;<br>       // 延迟1秒后，每间隔2秒执行一次<br>       scheduledExecutorService.scheduleAtFixedRate(runnable, 1, 2, TimeUnit.SECONDS);<br>   &#125;<br></code></pre></td></tr></table></figure><p>如下所示，我们执行任务需要3秒，而间隔时间是2秒，通过打印结果可以看出，任务之间间隔3秒，也就是会等待任务执行完成后才开始下一个任务：</p><img src="/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image(7).png" class=""><h4 id="scheduleWithFixedDelay方法"><a href="#scheduleWithFixedDelay方法" class="headerlink" title="scheduleWithFixedDelay方法"></a>scheduleWithFixedDelay方法</h4><p>如果任务之间必须具有固定长度的延迟，那么可以使用scheduleWithFixedDelay方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">private static void testScheduleWithFixDelay() &#123;<br>     ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();<br>     Runnable runnable = () -&gt; &#123;<br>         System.out.println(System.currentTimeMillis());<br>         try &#123;<br>             TimeUnit.SECONDS.sleep(3);<br>         &#125; catch (InterruptedException e) &#123;<br>             throw new RuntimeException(e);<br>         &#125;<br>         System.out.println(&quot;执行callable任务====&quot;);<br>     &#125;;<br>     // 延迟1秒后，每间隔2秒执行一次<br>     scheduledExecutorService.scheduleWithFixedDelay(runnable, 1, 2, TimeUnit.SECONDS);<br> &#125;<br><br></code></pre></td></tr></table></figure><p>在上述代码中，任务执行时长需要3秒，然后我们设置延迟时间为2秒，最终执行结果如下，从时间戳中可以看出，在上一个任务执行完毕后，间隔2秒才会开始下一个任务，因此任务与任务间隔时长为5秒。</p><img src="/2024/04/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image(8).png" class=""><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/qq_21484461/article/details/133101696">https://blog.csdn.net/qq_21484461&#x2F;article&#x2F;details&#x2F;133101696</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/02/hello-world/"/>
    <url>/2024/04/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
